'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@remote-ui/core');
var print = require('./print.js');

const IS_NODE = Symbol.for('RemoteUiTesting.Node');
function createTestRoot() {
  return core.createRemoteRoot(() => {});
}
function mount(run, root = createTestRoot()) {
  let acting = false;
  let mounted = true;
  let rootNode;
  act(() => {
    run(root);
  });
  const rootApi = new Proxy({
    act,
    unmount
  }, {
    get(target, key, receiver) {
      if (Reflect.ownKeys(target).includes(key)) {
        return Reflect.get(target, key, receiver);
      }

      return withRootNode(rootNode => Reflect.get(rootNode, key));
    }

  });
  return rootApi;

  function createNode({
    type,
    props,
    instance,
    children
  }) {
    const descendants = children.flatMap(getDescendants);

    function getDescendants(child) {
      return [child, ...(typeof child === 'string' ? [] : child.children.flatMap(getDescendants))];
    }

    const find = (type, props) => {
      var _ref;

      return (_ref = descendants.find(element => isNode(element) && element.type === type && (props == null || equalSubset(props, element.props)))) !== null && _ref !== void 0 ? _ref : null;
    };

    const node = {
      [IS_NODE]: true,
      type,
      props,
      instance,

      get text() {
        return children.reduce((text, child) => `${text}${typeof child === 'string' ? child : child.text}`, '');
      },

      prop: key => props[key],
      is: checkType => type === checkType,
      find,
      findAll: (type, props) => descendants.filter(element => isNode(element) && element.type === type && (props == null || equalSubset(props, element.props))),
      findWhere: predicate => {
        var _ref2;

        return (_ref2 = descendants.find(element => isNode(element) && predicate(element))) !== null && _ref2 !== void 0 ? _ref2 : null;
      },
      findAllWhere: predicate => descendants.filter(element => isNode(element) && predicate(element)),
      trigger: (prop, ...args) => act(() => {
        const propValue = props[prop];

        if (propValue == null) {
          throw new Error(`Attempted to call prop ${String(prop)} but it was not defined.`);
        }

        return propValue(...args);
      }, {
        eager: true
      }),
      triggerKeypath: (keypath, ...args) => act(() => {
        const parts = keypath.split(/[.[\]]/g).filter(Boolean);
        let currentProp = props;
        const currentKeypath = [];

        for (const part of parts) {
          if (currentProp == null || typeof currentProp !== 'object') {
            throw new Error(`Attempted to access field keypath '${currentKeypath.join('.')}', but it was not an object.`);
          }

          currentProp = currentProp[part];
          currentKeypath.push(part);
        }

        if (typeof currentProp !== 'function') {
          throw new Error(`Value at keypath '${keypath}' is not a function.`);
        }

        return currentProp(...args);
      }, {
        eager: true
      }),
      children,
      descendants,
      debug: options => print.nodeChildToString(node, options),
      toString: () => `<${print.nodeName(node)} />`
    };
    return node;
  }

  function unmount() {
    if (!mounted) {
      throw new Error('You attempted to unmount a node that was already unmounted');
    }

    mounted = false;
  } // Currently, we run the actions directly, so act isnâ€™t actually flushing
  // updates or anything like that. In the future, we could use the fact that
  // we force all actions to be nested in here to make other guarantees about
  // how the updates have been flushed to the passed `root` (right now, we
  // treat that root as a "noop").


  function act(action, {
    update = true,
    eager = false
  } = {}) {
    const performUpdate = update ? updateRootNode : noop;

    if (acting) {
      return action();
    }

    acting = true;

    const afterResolve = () => {
      performUpdate();
      acting = false;
      return result;
    };

    const result = action();

    if (isPromise(result)) {
      if (eager) {
        performUpdate();
        return act(() => Promise.resolve(result).then(() => {})).then(afterResolve);
      } else {
        return Promise.resolve(result).then(afterResolve);
      }
    }

    return afterResolve();
  }

  function createNodeFromRemoteChild(child) {
    return core.isRemoteText(child) ? child.text : createNode({
      type: child.type,
      props: { ...child.props
      },
      instance: child,
      children: child.children.map(createNodeFromRemoteChild)
    });
  }

  function updateRootNode() {
    rootNode = createNode({
      type: null,
      props: {},
      children: root.children.map(child => createNodeFromRemoteChild(child)),
      instance: root
    });
  }

  function withRootNode(perform) {
    if (!mounted) {
      throw new Error('Attempted to operate on a mounted tree, but it is not mounted. Did you forget to call .mount()? If not, have you already called .unmount()?');
    }

    return perform(rootNode);
  }
}
function isNode(maybeNode) {
  return maybeNode != null && maybeNode[IS_NODE];
}

function isPromise(promise) {
  return typeof (promise === null || promise === void 0 ? void 0 : promise.then) === 'function';
}

function equalSubset(subset, full) {
  return Object.keys(subset).every(key => key in full && full[key] === subset[key]);
}

function noop() {}

exports.createTestRoot = createTestRoot;
exports.isNode = isNode;
exports.mount = mount;
